# 알고리즘 개요 2

<br>

> ### 점근적 분석

<br>

#### # 시간 복잡도와 공간 복잡도

- 시간 복잡도 (Time Complexity)

  : 알고리즘의 연산 수에 따른 수행시간 분석결과

- 공간 복잡도 (Space Complexity)

  : 알고리즘이 소요하는 메모리 사용량에 대한 분석결과

  **알고리즘의 성능 평가는 시간 복잡도와 공간 복잡도를 계산하고 점근적 표기법으로 표현**

<br>

#### # 점근적 분석의 필요성

주어진 문제를 푸는 알고리즘은 하나만 있는 것이 아니라

하드웨어, 운영체제, 프로그래밍 언어 등에 따라서 최적화된 여러 알고리즘이 존재한다.

어떤 문제를 해결하는 데에는 다수 개의 알고리즘이 존재할 수 있으므로 알고리즘의 성능을 비교할 필요가 있다.

<br>

점근적 분석법은 각 알고리즘이 주어진(입력되는) 데이터의 크기를 기준으로

**수행시간 혹은 사용공간이 얼마나 되는지를 측정하여 객관적으로 비교할 수 있는 기준**을 제시해준다.

이를 통해 효율적인 알고리즘인지를 판단한다.

<br>

#### # 알고리즘의 성능분석

주어진 데이터의 크기보다, 어떠한 데이터가 입력되는가에 따라 알고리즘 성능에 더 영향을 미칠 수 있다.

다음 주어진 데이터에서 각 행 별로 가장 작은 값을 찾아보자.

```c
int data[3][5] = { { 1, 4, 6, 8, 5 },
		   { 6, 4, 1, 5, 8 },
		   { 8, 6, 5, 4, 1 } };
```

이 데이터에서 각 행의 주어진 숫자와 열의 개수는 다섯 개로 같지만, 데이터의 나열 순서는 다르다.

가장 작은 값은 모두 1이고, 아래 코드는 각 5번의 반복문을 수행한다.

따라서 몇 번 만에 가장 작은 값을 찾았는지 비교를 위해 if문의 수행 횟수를 비교해보자.

```c
	for (int i = 0; i < 3; i++) {
		int min = 10; // count 비교를 위해 10으로 고정함
		int count = 0;
		for (int j = 0; j < 5; j++) { // count 비교를 위해 0번 방부터 수행함
			if (min > data[i][j]) {
				min = data[i][j];
				count++;
			}
		}
		printf("%d번째 행 : %d번 수행\n", i + 1, count);
	}
	// 수행 결과
	// 1번째 행 : 1번 수행
	// 2번째 행 : 3번 수행
	// 3번째 행 : 5번 수행
```

수행 결과를 통해 세 가지 경우로 나뉜 것을 알 수 있다.

1번째 행 { 1, 4, 6, 8, 5 } - **최선의 경우 (Best Case)/Ω 표기** : 대부분 첫 수행에 찾음

2번째 행 { 6, 4, 1, 5, 8 } - **평균적인 경우 (Average Case)/Θ 표기** : 최선과 최악의 평균

3번째 행 { 8, 6, 5, 4, 1 } - **최악의 경우 (Worst Case)/O 표기** : 대부분 마지막 수행에 찾음

<br>

평균적인 경우가 가장 이상적으로 보이겠지만 알고리즘이 복잡해질수록 평균적인 경우는 구하기가 어려워진다.

최악인 경우일 때 어떤 성능을 지녔는지 판단해야 평균과 가까운 성능을 예측할 수 있기에 

주로 **최악의 경우 (Worst Case)** 를 측정할 수 있는 **O(빅오) 표기법**으로 알고리즘의 성능을 파악한다.

<br>

#### # 점근적 분석의 예

- #####  상수 (Constant) 시간 복잡도

```c
/* 입력으로 n개의 데이터가 저장된 배열 data가 주어진다 */
int func (int data[], int n) {
	int k = n/2;
	return data[k];
}
/* 그 중 n/2번째 데이터를 반환한다 */
```

**O(1)** - n에 관계없이 상수 시간이 소요된다.

- ##### 선형 (Linear) 시간 복잡도

```c
/* 입력으로 n개의 데이터가 저장된 배열 data가 주어진다 */
int func (int data[], int n) {
	int sum = 0;
	for (int i = 0; i < n; i++)
		sum = sum + data[i]; // 이 알고리즘에서 가장 자주 실행되는 문장
	return sum;
}
/* n개의 데이터의 합을 구하여 반환한다 */
```

**O(n)** - 가장 자주 실행되는 문장의 실행 횟수가 n번이며, 모든 문장과 연산들의 실행 횟수의 합도 n에 선형적으로 비례한다.

다음은 **순차탐색**으로, 배열 data에 정수 target이 있는지 검색한다. 이 알고리즘의 수행 횟수는 **최악의 경우** n번이다.

```C
int search(int n, int data[], int target) {
	for (int i = 0; i < n; i++) {
		if (data[i] == target) // 이 알고리즘에서 가장 자주 실행되는 문장
			return i;
	}
	return -1;
}
```

- ##### 이차 (Quadratic) 시간 복잡도

```c
/* 입력으로 n개의 데이터가 저장된 배열 x가 주어진다 */
bool is_distinct(int n, int x[]) {
	for (int i = 0; i < n - 1; i++)
		for (int j = i + 1; j < n; j++)
			if (x[i] == x[j]) // 이 알고리즘에서 가장 자주 실행되는 문장
				return false;
	return true;
}
/* 배열 x에 중복된 원소가 있는지 검사 결과를 반환한다 */
```

**O(n²)** - 최악의 경우 배열에 저장된 모든 원소 쌍을 비교하므로 비교 연산의 횟수는 n(n-1)/2번이다.

<br>

******
#### 참고

###### [블로그] [https://ledgku.tistory.com](https://ledgku.tistory.com/31) - 내용

