# [백준] 1051 - 숫자 정사각형

<br>

#### 문제 분류

- 브루트 포스

<br>

#### 사용 언어

- C++

<br>

## 문제 설명

N * M 크기의 직사각형이 있다. 각 칸은 한 자리 숫자가 적혀 있다.

이 직사각형에서 꼭짓점에 쓰여 있는 수가 모두 같은 가장 큰 정사각형을 찾는 프로그램을 작성하시오.

이때, 정사각형은 행 또는 열에 평행해야 한다.

<br>

### 입력

첫째 줄에 N과 M이 주어진다. N과 M은 50보다 작거나 같은 자연수이다.

둘째 줄부터 N개의 줄에 수가 주어진다.

<br>

#### 입력 예

```
3 5
42101
22100
22101
```

<br>

### 출력

첫째 줄에 정답 정사각형의 크기를 출력한다.

<br>

#### 출력 예

```
9
```

<br>

<br>

## 문제 풀이

사각형의 밑변과 높이로 입력되는 N과 M 중 작은 값이 정사각형의 가장 큰 변의 길이가 될 가능성이 있습니다.

따라서 먼저, 꼭짓점 사이의 간격을 저장할 변수 k를 두고 n과 m을 비교하여 더 작은 값을 대입하였습니다.

사각형의 꼭짓점 사이 간격이 없으면 그 사각형의 크기는 1이기 때문에, 변수 k의 값이 0이 되면 while 반복문을 종료하고 1을 리턴하도록 하였습니다.

while 반복문 안의 for 반복문에서는 검사하려는 꼭짓점이 변수 k인 꼭짓점 간격 만큼의 나머지 세 꼭짓점과

같은 수가 쓰여있는지를 확인하였습니다.

만약 네 꼭짓점 모두 같은 수가 쓰여있다면, 변수 k인 꼭짓점 사이 간격에 1 증가시켜 정사각형의 크기를 반환하였습니다.

<br>

### CODE

#### ▶ My Code

```c++
#include <iostream>

using namespace std;

int solution(int n, int m, char square[50][50]){
	int k = (n < m ? n : m);

	while(k>0) {
		k--;
		for(int i=0; i+k<n; i++) {
			for(int j=0; j+k<m; j++) {
				if(square[i][j]==square[i+k][j] && square[i][j]==square[i][j+k] && square[i][j]==square[i+k][j+k]) {
					return (++k * k);
				}
			}
		}
	}

	return 1;
}

int main() {
	int n, m;
	char square[50][50];

	cin >> n >> m;
	for(int i=0; i<n; i++) {
		cin >> square[i];
	}
	cout << solution(n, m, square) << endl;

	return 0;
}
```

모든 식의 계산(평가)이 완료되는 시점을 시퀀스 포인트라고 합니다. 그리고 시퀀스 포인트 사이에서 식의 값은 한 번만 수정될 수 있습니다.

시퀀스 포인트의 여러 가지 중 다음은 return으로 값을 반환하기 직전에 값이 두 번 수정된 잘못된 코드입니다.

Visual Studio에서는 경고 없이 컴파일되지만 GCC에서는 -Wsequence-point 또는 -Wall옵션을 사용하여 경고를 출력할 수 있습니다.

```c++
Main.cc: In function ‘int solution(int, int, char (*)[50])’:
Main.cc:13:29: warning: operation on ‘k’ may be undefined [-Wsequence-point]
                     return (++k * k);
                             ^~~
```

return (++k * k) 을 보면 k는 ++k에서 값이 한 번 수정되고 다음 곱할 k의 값도 증가하기 때문에 다시 수정됩니다.

이와 같이 의도가 명확하지 않은 코드를 정의되지 않은 행동(undefined behavior)라 부르는데,

컴파일러에 따라 결과가 달라질 수 있으므로 이런 코드의 작성은 피해야 합니다.

그래서 다음과 같이 코드를 수정하였습니다.

```c++
return (k+1) * (k+1);
```

<br>

### MEMO

#### # 시퀀스 포인트

- 모든 식의 계산(평가)이 완료되는 시점을 시퀀스 포인트라고 합니다.

- 시퀀스 포인트 사이에서 식의 값은 한 번만 수정될 수 있습니다.

| 이름                     | 구문                   | 설명                                                         |
| ------------------------ | ---------------------- | ------------------------------------------------------------ |
| 논리 AND 연산자          | &&                     | && 연산자 앞에서 모든 식의 계산이 완료되며 첫 번째 식의 결과에 따라 두 번째 식은 평가하지 않고 넘어가는 단락 평가를 수행합니다. |
| 논리 OR 연산자           | \|\|                   | \|\| 연산자 앞에서 모든 식의 계산이 완료되며 첫 번째 식의 결과에 따라 두 번째 식은 평가하지 않고 넘어가는 단락 평가를 수행합니다. |
| 쉼표 연산자              | ,                      | , 연산자 앞에서 모든 식의 계산이 완료됩니다. 따라서 다음과 같이 i++과 i++을 콤마로 구분한 코드는 올바른 코드입니다.`// 시퀀스 포인트 사이에서 값이 두 번 수정됨. 정의되지 않은 행동 x = (i++ + i++, i += 2); // 시퀀스 포인트 사이에서 값이 한 번 수정됨. 올바른 코드 x = (i++, i++, i += 2);` |
| 함수 호출 연산자         | ( )                    | 함수 호출 직전까지 모든 식의 계산이 완료됩니다. 다음과 같이 함수 앞에서 i++가 수행되고, 함수의 인수에서 i++가 수행되어 값이 두 번 수정되었습니다. 즉, 함수 호출 연산자 ( )의 안쪽뿐만 아니라 함수 바깥의 식도 함께 평가됩니다.`#include   int function(int n) {    return n; }  int main() {    int i = 0;    int x;     x = i++ + function(i++); // 함수 호출 전에 값이 두 번 수정됨                             // 정의되지 않은 행동     return 0; }  ` |
| 삼항 연산자              | ?                      | ?로 조건을 판단하기 전까지 모든 식의 계산이 완료됩니다.      |
| 세미콜론                 | ;                      | ; 직전에 모든 식의 계산이 완료됩니다.                        |
| if, switch의 조건식      | if ( ) switch ( )      | if, switch에 연결된 코드가 실행되기 직전에 모든 식의 계산이 완료됩니다. |
| while, do while의 조건식 | while ( ) do while ( ) | 반복될 코드가 실행되기 직전에 모든 식의 계산이 완료됩니다.   |
| for 제어문의 세미콜론    | for ( ; ; )            | 각 세미콜론 직전에 모든 식의 계산이 완료됩니다(반복될 코드가 실행되기 직전에도 모든 식의 계산이 완료됩니다). |
| 함수의 반환              | return                 | return으로 값을 반환하기 직전에 모든 식의 계산이 완료됩니다. |

<br>

******

#### 출처

###### [Baekjoon] [1051번 : 숫자 정사각형](https://www.acmicpc.net/problem/1051) - 문제

###### [코딩도장] [C언어 코딩 도장 : 85.17](https://dojang.io/mod/page/view.php?id=757) - 시퀀스 포인트

